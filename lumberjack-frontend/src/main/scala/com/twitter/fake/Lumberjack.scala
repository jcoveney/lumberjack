package com.twitter.fake

import scala.collection.Iterator
import org.apache.pig.data.{Tuple, DataBag}
import java.util.{Iterator => jIterator}

/**
 * This is a fake class to show what the autogenerated "Trunk" may look like. A Trunk is a case class
 * which has the filter etc operations, but also is a case class generated to represent the redelm file
 */

object Lumberjack {

  object MessageTypeNameMT {
    def apply(t:Tuple) = new MessageTypeNameMT(t)
    lazy val getDummyWrapper = apply(null)
  }
  class MessageTypeNameMT private (t:Tuple){
    object Ljt2 {
      def apply(t:Tuple) = new Ljt2(t)
    }
    class Ljt2 private (t:Tuple) {
      val name:String = t.get(0).asInstanceOf
    }

    object Ljb3 {
      def apply(wrappedBag:DataBag) = new Ljb3(wrappedBag)
    }
    class Ljb3 private (wrappedBag:DataBag) extends Iterable[Ljbt3] {
      override def iterator: Iterator[Ljbt3] = new Iterator[Ljbt3] {
        private val wrappedIterator:jIterator[Tuple] = wrappedBag.iterator
        override def next():Ljbt3 = Ljbt3(wrappedIterator.next())
        override def hasNext:Boolean = wrappedIterator.hasNext
      }
    }

    object Ljbt3 {
      def apply(t:Tuple) = new Ljbt3(t)
    }
    class Ljbt3 private (t:Tuple){
      def name:String = t.get(0).asInstanceOf
    }

    val mapTemplate =
"""object %1$s {
  def apply(m:Map[String,Object]) = new %1$s(m)
}
class %1$s private (m:Map[String,Object) {
  def get(key:String):%2$s = %2$s(m.get(key).asInstanceOf)
}"""

    val bagTemplate =
"""object %1$s {
  apply(wrappedBag:DataBag) = new %1$s(wrappedBag)
}
class %1$s private (wrappedBag:DataBag) extends Iterable[%2$s] {
  override def iterator:Iterator[%2$s] = new Iterator[%2$s] {
    private val wrappedIterator:jIterator[Tuple] = wrappedBag.iterator
    override def next():%2$s = %2$s(wrappedIterator.next())
    override def hasNext:Boolean = wrappedIterator.hasNext
  }
}"""

    val tupleTemplate =
"""object NAME {
  def apply(t:Tuple) = new NAME(t)
}
class NAME {
CLASSDEFINITONS
FIELDS
}"""

    val basseTemplate =
"""object NAME {
  def apply(t:Tuple) = new NAME(t)
  lazy val getDummyWrapper = apply(null)
}
class NAME {
CLASSDEFINITONS
FIELDS
}"""

    object Ljm4 {
      def apply(m:Map[String,Object]) = new Ljm4(m)
    }
    //TODO if we have the type info then it should be typed
    //TODO it can be a tuple, or a single bag or primitive
    class Ljm4 private (m:Map[String,Object]) {
      def get(key:String):Ljm4t = Ljm4t(m.get(key).asInstanceOf)
    }
    // in a simpler case could just make it a type Ljmt4 = Int or somesuch? Though bags and maps need the recursing
    object Ljm4t {
      def apply(t:Tuple) = new Ljm4t(t)
    }
    class Ljm4t private (t:Tuple) {
      def info1:String = t.get(0).asInstanceOf
      def info2:String = t.get(1).asInstanceOf
    }

    //TODO if we make a new class per can make these lazy vals
    def name:String = t.get(0).asInstanceOf
    def age:Int = t.get(1).asInstanceOf
    def schoolInfo:Ljt2 = Ljt2(t.get(2).asInstanceOf)
    def classmates:Ljb3 = Ljb3(t.get(3).asInstanceOf)
    def classmateInfo:Ljm4 = Ljm4(t.get(4).asInstanceOf)
  }
}

